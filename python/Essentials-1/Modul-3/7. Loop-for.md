# Looping your code with for
Another kind of loop available in Python comes from the observation that sometimes it's more important to `count the "turns" of the loop` than to check the conditions.

Imagine that a loop's body needs to be executed exactly one hundred times. If you would like to use the `while` loop to do it, it may look like this:
```py
i = 0
while i < 100:
    # do_something()
    i += 1
```

It would be nice if somebody could do this boring counting for you. Is that possible?

Of course it is - there's a special loop for these kinds of tasks, and it is named `for`.

Actually, the `for` loop is designed to do more complicated tasks - `it can "browse" large collections of data item by item`. We'll show you how to do that soon, but right now we're going to present a simpler variant of its application.

Take a look at the snippet:
```py
for i in range(100):
    # do_something()
    pass
```

There are some new elements. Let us tell you about them:

  - the for keyword opens the `for` loop; note - there's no condition after it; you don't have to think about conditions, as they're checked internally, without any intervention;
  - any variable after the for keyword is the `control variable` of the loop; it counts the loop's turns, and does it automatically;
  - the in keyword introduces a syntax element describing the range of possible values being assigned to the control variable;
  - the `range()` function (this is a very special function) is responsible for generating all the desired values of the control variable; in our example, the function will create (we can even say that it will feed the loop with) subsequent values from the following set: 0, 1, 2 .. 97, 98, 99; note: in this case, the range() function starts its job from 0 and finishes it one step (one integer number) before the value of its argument;
  - note the pass keyword inside the loop body - it does nothing at all; it's an `empty instruction` - we put it here because the `for` loop's syntax demands at least one instruction inside the body (by the way - `if`, `elif`, `else` and `while` express the same thing)
Our next examples will be a bit more modest in the number of loop repetitions.

Take a look at the snippet below. Can you predict its output?
```py
for i in range(10):
    print("The value of i is currently", i)
```

Run the code to check if you were right.

## Note:

  - the loop has been executed ten times (it's the `range()` function's argument)
  - the last control variable's value is `9` (not `10`, as `it starts from 0`, not from `1`)

The `range()` function invocation may be equipped with two arguments, not just one:
```py
for i in range(2, 8):
    print("The value of i is currently", i)
```

In this case, the first argument determines the initial (first) value of the control variable.

The last argument shows the first value the control variable will not be assigned.

Note: the `range()` function `accepts only integers as its arguments`, and generates sequences of integers.

Can you guess the output of the program? Run it to check if you were right now, too.

The first value shown is `2` (taken from the `range()`'s first argument.)

The last is `7` (although the `range()`'s second argument is `8`).

=================================================================================================
# More about the for loop and the range() function with three arguments
The `range()` function may also accept `three arguments` - take a look at the code in the editor.

The third argument is an `increment` - it's a value added to control the variable at every loop turn (as you may suspect, the `default value of the increment is 1`).

Can you tell us how many lines will appear in the console and what values they will contain?
Run the program to find out if you were right.
```py
for i in range(2, 8, 3):
    print("The value of i is currently", i)
```

You should be able to see the following lines in the console window:
```s
The value of i is currently 2
The value of i is currently 5
```

Do you know why? The first argument passed to the `range()` function tells us what the `starting` number of the sequence is (hence `2` in the output). The second argument tells the function where to `stop` the sequence (the function generates numbers up to the number indicated by the second argument, but does not include it). Finally, the third argument indicates the `step`, which actually means the difference between each number in the sequence of numbers generated by the function.

`2` (starting number) → `5` (`2` increment by 3 equals `5` - the number is within the range from 2 to 8) → `8` (`5` increment by 3 equals `8` - the number is not within the range from 2 to 8, because the stop parameter is not included in the sequence of numbers generated by the function.)

Note: if the set generated by the `range()` function is empty, the loop won't execute its body at all.

Just like here - there will be no output:
```py
for i in range(1, 1):
    print("The value of i is currently", i)
```

Note: the set generated by the `range()` has to be sorted in `ascending order`. There's no way to force the `range()` to create a set in a different form when the `range()` function accepts exactly two arguments. This means that the `range()`'s second argument must be greater than the first.

Thus, there will be no output here, either:
```py
for i in range(2, 1):
    print("The value of i is currently", i)
```

Let's have a look at a short program whose task is to write some of the first powers of two:
```py
power = 1
for expo in range(16):
    print("2 to the power of", expo, "is", power)
    power *= 2
```

The `expo` variable is used as a control variable for the loop, and indicates the current value of the exponent. The exponentiation itself is replaced by multiplying by two. Since 20 is equal to 1, then 2 × 1 is equal to 21, 2 × 21 is equal to 22, and so on. What is the greatest exponent for which our program still prints the result?

Run the code and check if the output matches your expectations.

